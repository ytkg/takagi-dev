#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import React, { createElement as h, useEffect, useState } from 'react';
import { render, Text, Box, useInput, useApp, useStdin } from 'ink';

function parseJsonl(text) {
  return text
    .split(/\r?\n/)
    .map((l) => l.trim())
    .filter(Boolean)
    .map((line) => {
      try {
        const obj = JSON.parse(line);
        const tags = Array.isArray(obj.tags) ? obj.tags : [];
        return { url: obj.url, title: obj.title, tags };
      } catch {
        return null;
      }
    })
    .filter((v) => v !== null);
}

async function loadBookmarks() {
  const __dirname = path.dirname(fileURLToPath(import.meta.url));
  const root = path.resolve(__dirname, '..');
  const dataPath = path.join(root, 'src', 'data', 'bookmarks.jsonl');
  const content = await fs.readFile(dataPath, 'utf8').catch((err) => {
    if (err.code === 'ENOENT') {
      console.error('bookmarks.jsonl not found at', dataPath);
      process.exit(1);
    }
    throw err;
  });
  return parseJsonl(content);
}

async function getDataPath() {
  const __dirname = path.dirname(fileURLToPath(import.meta.url));
  const root = path.resolve(__dirname, '..');
  return path.join(root, 'src', 'data', 'bookmarks.jsonl');
}

async function saveBookmarks(records) {
  const dataPath = await getDataPath();
  const lines = (records || []).map((r) => JSON.stringify(r));
  const content = lines.join('\n') + (lines.length ? '\n' : '');
  await fs.writeFile(dataPath, content, 'utf8');
}

function List({ items }) {
  const { exit } = useApp();
  const [list, setList] = useState(items || []);
  const [index, setIndex] = useState(0);
  const [mode, setMode] = useState('list'); // list | action | edit | input-title | input-tags | confirm-delete | message
  const [menuIndex, setMenuIndex] = useState(0);
  const [inputText, setInputText] = useState('');
  const [info, setInfo] = useState('');
  const { isRawModeSupported } = useStdin();
  const interactive = !!isRawModeSupported;

  const clampIndex = (i) => {
    const n = list.length;
    if (n === 0) return 0;
    if (i < 0) return 0;
    if (i > n - 1) return n - 1;
    return i;
  };

  interactive && useInput((input, key) => {
    if (mode === 'list') {
      if (key.upArrow) setIndex((i) => (i <= 0 ? Math.max(0, list.length - 1) : i - 1));
      else if (key.downArrow) setIndex((i) => (i >= list.length - 1 ? 0 : i + 1));
      else if (key.return) { setMode('action'); setMenuIndex(0); }
      else if (key.escape || input === 'q' || (key.ctrl && input === 'c')) exit();
    } else if (mode === 'action') {
      const opts = ['Edit', 'Delete', 'Cancel'];
      if (key.upArrow) setMenuIndex((i) => (i <= 0 ? opts.length - 1 : i - 1));
      else if (key.downArrow) setMenuIndex((i) => (i >= opts.length - 1 ? 0 : i + 1));
      else if (key.escape) setMode('list');
      else if (key.return) {
        const sel = opts[menuIndex];
        if (sel === 'Edit') { setMode('edit'); setMenuIndex(0); }
        else if (sel === 'Delete') { setMode('confirm-delete'); setMenuIndex(0); }
        else setMode('list');
      }
    } else if (mode === 'edit') {
      const opts = ['Title', 'Tags', 'Back'];
      if (key.upArrow) setMenuIndex((i) => (i <= 0 ? opts.length - 1 : i - 1));
      else if (key.downArrow) setMenuIndex((i) => (i >= opts.length - 1 ? 0 : i + 1));
      else if (key.escape) setMode('list');
      else if (key.return) {
        const sel = opts[menuIndex];
        if (sel === 'Title') { setInputText(list[index]?.title ?? ''); setMode('input-title'); }
        else if (sel === 'Tags') { setInputText((list[index]?.tags || []).join(',')); setMode('input-tags'); }
        else setMode('list');
      }
    } else if (mode === 'input-title' || mode === 'input-tags') {
      if (key.escape) { setMode('list'); return; }
      if (key.return) {
        const commit = async () => {
          const newList = list.slice();
          if (!newList[index]) return;
          if (mode === 'input-title') newList[index] = { ...newList[index], title: inputText.trim() || newList[index].url };
          else newList[index] = { ...newList[index], tags: inputText.split(',').map((s) => s.trim()).filter(Boolean) };
          await saveBookmarks(newList);
          setList(newList);
          setInfo(mode === 'input-title' ? 'Title updated' : 'Tags updated');
          setMode('list');
        };
        void commit();
        return;
      }
      if (key.backspace || key.delete) {
        setInputText((t) => t.slice(0, -1));
      } else if (input) {
        setInputText((t) => t + input);
      }
    } else if (mode === 'confirm-delete') {
      const opts = ['No', 'Yes'];
      if (key.upArrow || key.downArrow) setMenuIndex((i) => (i === 0 ? 1 : 0));
      else if (key.escape) setMode('list');
      else if (key.return) {
        const sel = opts[menuIndex];
        if (sel === 'Yes') {
          const commit = async () => {
            const newList = list.filter((_, i) => i !== index);
            await saveBookmarks(newList);
            setList(newList);
            setIndex((i) => clampIndex(i));
            setInfo('Deleted');
            setMode('list');
          };
          void commit();
        } else {
          setMode('list');
        }
      }
    }
  });

  if (!list || list.length === 0) {
    return h(Text, { color: 'gray' }, 'No bookmarks found. (q to quit)');
  }

  const renderMenu = (label, options) => (
    h(Box, { flexDirection: 'column', marginTop: 1 },
      h(Text, { color: 'gray' }, label),
      ...options.map((opt, i) => h(Text, { key: opt, color: i === menuIndex ? 'cyan' : undefined }, `${i === menuIndex ? '› ' : '  '}${opt}`)),
    )
  );

  return h(
    Box,
    { flexDirection: 'column' },
    [
      info ? h(Text, { key: 'info', color: 'gray' }, info) : null,
      h(Text, { key: 'help', color: 'gray' }, interactive ? 'Use ↑/↓ to select, Enter to open menu, q to quit' : 'Interactive input not supported; showing static list'),
      ...list.map((b, i) => {
        const selected = i === index;
        return h(
          Box,
          { key: `${b.url}-${i}`, flexDirection: 'row' },
          h(Text, { color: selected ? 'cyan' : 'gray' }, selected ? '› ' : '  '),
          h(
            Text,
            selected ? { backgroundColor: 'cyan', color: 'black' } : {},
            `${b.title ?? '(no title)'}  ${b.url ?? ''}  ${
              b.tags && b.tags.length ? b.tags.map((t) => `#${t}`).join(' ') : ''
            }`,
          ),
        );
      }),
      interactive && mode === 'action' && renderMenu('Choose action', ['Edit', 'Delete', 'Cancel']),
      interactive && mode === 'edit' && renderMenu('Edit which field?', ['Title', 'Tags', 'Back']),
      interactive && mode === 'input-title' && h(Box, { flexDirection: 'column', marginTop: 1 },
        h(Text, { color: 'gray' }, 'Enter new title and press Enter (Esc to cancel)'),
        h(Text, null, inputText + '▌'),
      ),
      interactive && mode === 'input-tags' && h(Box, { flexDirection: 'column', marginTop: 1 },
        h(Text, { color: 'gray' }, 'Enter comma-separated tags and press Enter (Esc to cancel)'),
        h(Text, null, inputText + '▌'),
      ),
      interactive && mode === 'confirm-delete' && renderMenu('Delete this bookmark?', ['No', 'Yes']),
    ].filter(Boolean),
  );
}

async function main(argv) {
  const [,, cmd] = argv;
  if (!cmd || cmd === 'help' || cmd === '--help' || cmd === '-h') {
    console.log('Usage: bm <command>');
    console.log('Commands:');
    console.log('  list   Show bookmarks list');
    console.log('  add <url>   Add a bookmark with fetched title (duplicates are skipped with a warning)');
    console.log('  update-images [--force]   Fetch og:image for existing records (fill missing by default)');
    process.exit(0);
  }

  if (cmd === 'list') {
    const items = await loadBookmarks();
    const app = h(List, { items });
    const instance = render(app);
    await instance.waitUntilExit();
    return;
  }

  if (cmd === 'add') {
    const urlArg = argv[3];
    if (!urlArg) {
      console.error('Usage: bm add <url>');
      process.exit(1);
    }
    const app = h(AddCommand, { url: urlArg });
    const instance = render(app);
    await instance.waitUntilExit();
    return;
  }

  if (cmd === 'update-images') {
    const force = argv.includes('--force');
    const app = h(UpdateImagesCommand, { force });
    const instance = render(app);
    await instance.waitUntilExit();
    return;
  }

  console.error(`Unknown command: ${cmd}`);
  process.exit(1);
}

main(process.argv);

// ----- Add command components / helpers -----

function normalizeUrl(input) {
  try {
    const hasScheme = /^(https?:)?\/\//i.test(input);
    const u = new URL(hasScheme ? input : `https://${input}`);
    return u.toString();
  } catch {
    return null;
  }
}

function resolveUrlMaybe(value, base) {
  try {
    return new URL(value, base).toString();
  } catch {
    return null;
  }
}

async function fetchPageMeta(url) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 10000);
  try {
    const res = await fetch(url, {
      signal: controller.signal,
      headers: {
        'user-agent': 'bm-cli/1.0 (+https://takagi.dev)'
      }
    });
    const html = await res.text();

    // Title
    let title = null;
    const mt = html.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
    if (mt) title = (mt[1] || '').replace(/\s+/g, ' ').trim() || null;

    // Meta tags parsing
    let image = null;
    const headMatch = html.match(/<head[\s\S]*?<\/head>/i);
    const head = headMatch ? headMatch[0] : html;
    const metas = head.match(/<meta\b[^>]*>/gi) || [];
    const candidates = [];
    for (const tag of metas) {
      const attrs = {};
      const re = /([a-zA-Z\-:]+)\s*=\s*(["'])(.*?)\2/g;
      let m;
      while ((m = re.exec(tag))) {
        attrs[m[1].toLowerCase()] = m[3];
      }
      const prop = (attrs.property || attrs.name || '').toLowerCase();
      if (prop === 'og:image' || prop === 'og:image:secure_url' || prop === 'twitter:image' || prop === 'twitter:image:src') {
        if (attrs.content) candidates.push(attrs.content);
      }
    }
    for (const c of candidates) {
      const abs = resolveUrlMaybe(c, url);
      if (abs) { image = abs; break; }
    }

    return { title, image };
  } finally {
    clearTimeout(timeout);
  }
}

async function appendBookmark(record) {
  const dataPath = await getDataPath();
  let needsLeadingNewline = false;
  try {
    const current = await fs.readFile(dataPath, 'utf8');
    needsLeadingNewline = current.length > 0 && !current.endsWith('\n');
  } catch (e) {
    if (e.code !== 'ENOENT') throw e;
  }
  const line = JSON.stringify(record);
  const payload = (needsLeadingNewline ? '\n' : '') + line + '\n';
  await fs.appendFile(dataPath, payload, 'utf8');
}

function AddCommand({ url }) {
  const [state, setState] = useState({ step: 'init', message: '', color: 'white' });

  useEffect(() => {
    (async () => {
      const normalized = normalizeUrl(url);
      if (!normalized) {
        setState({ step: 'done', message: `Invalid URL: ${url}`, color: 'red' });
        return;
      }
      setState({ step: 'fetch', message: `Fetching title...`, color: 'yellow' });

      const list = await loadBookmarks();
      const cmp = (u) => (u && u.endsWith('/') ? u.slice(0, -1) : u);
      if (list.some((b) => cmp(b.url) === cmp(normalized))) {
        setState({ step: 'done', message: `Warning: already exists, skipped: ${normalized}`, color: 'yellow' });
        return;
      }

      const meta = await fetchPageMeta(normalized);
      const title = meta.title || normalized;
      const image = meta.image || undefined;

      const record = { url: normalized, title, tags: [], ...(image ? { image } : {}) };
      await appendBookmark(record);
      setState({ step: 'done', message: `Added: ${title} (${normalized})`, color: 'green' });
    })().catch((e) => {
      setState({ step: 'done', message: String(e?.message ?? e), color: 'red' });
    });
  }, [url]);

  return h(Text, { color: state.color }, state.message || '');
}

function UpdateImagesCommand({ force }) {
  const [lines, setLines] = useState(['Starting image update...']);
  const [summary, setSummary] = useState('');

  useEffect(() => {
    (async () => {
      const list = await loadBookmarks();
      const next = list.slice();
      let updated = 0;
      for (let i = 0; i < list.length; i++) {
        const b = list[i];
        if (!force && b.image) {
          setLines((ls) => [...ls, `skip: ${b.url} (has image)`]);
          continue;
        }
        setLines((ls) => [...ls, `fetch: ${b.url}`]);
        try {
          const meta = await fetchPageMeta(b.url);
          if (meta.image) {
            next[i] = { ...b, image: meta.image };
            updated++;
            setLines((ls) => [...ls, `  -> updated image: ${meta.image}`]);
          } else {
            setLines((ls) => [...ls, `  -> no image found`]);
          }
        } catch (e) {
          setLines((ls) => [...ls, `  -> error: ${String(e?.message ?? e)}`]);
        }
      }
      if (updated > 0) await saveBookmarks(next);
      setSummary(`Done. Updated: ${updated}, Total: ${list.length}${force ? ' (force)' : ''}`);
    })().catch((e) => setSummary(`Failed: ${String(e?.message ?? e)}`));
  }, [force]);

  return h(Box, { flexDirection: 'column' }, [
    ...lines.map((l, i) => h(Text, { key: i }, l)),
    summary ? h(Text, { key: 'sum', color: 'green' }, summary) : null,
  ].filter(Boolean));
}
